diff -urNp mcelog-1.0pre3_20120814_2.orig/leaky-bucket.c mcelog-1.0pre3_20120814_2/leaky-bucket.c
--- mcelog-1.0pre3_20120814_2.orig/leaky-bucket.c	2014-03-26 10:19:47.401123566 -0400
+++ mcelog-1.0pre3_20120814_2/leaky-bucket.c	2014-03-26 10:27:48.000159071 -0400
@@ -69,7 +69,7 @@ static int timeconv(char unit, int *out)
 	unsigned corr = 1;
 	switch (unit) { 
 	case 'd': corr *= 24;
-	case 'h': corr *= 3600;
+	case 'h': corr *= 60;
 	case 'm': corr *= 60;
 	case 0:   break;
 	default: return -1;
@@ -151,3 +151,70 @@ void bucket_init(struct leaky_bucket *b)
 	b->excess = 0;
 	b->tstamp = bucket_time();
 }
+
+
+#ifdef TEST_LEAKY_BUCKET
+/* Stolen from the cpp documentation */
+#define xstr(_s) str(_s)
+#define str(_s) #_s
+
+#define THRESHOLD_EVENTS_PER_PERIOD 100
+#define EVENTS_PER_LOGGED_EVENT 10
+#define SECONDS_PER_EVENT 86
+/* Needs to be SECONDS_PER_EVENT * EVENTS_PER_LOGGED_EVENT * THRESHOLD_EVENTS_PER_PERIOD */
+#define THRESHOLD_PERIOD 86000
+#if THRESHOLD_PERIOD != (SECONDS_PER_EVENT * EVENTS_PER_LOGGED_EVENT * THRESHOLD_EVENTS_PER_PERIOD)
+#  error THRESHOLD_PERIOD is Wrong!
+#endif
+#define RATE_STRING xstr(THRESHOLD_EVENTS_PER_PERIOD) " / " xstr(THRESHOLD_PERIOD)
+
+#define EVENTS_PER_PERIOD_IN_TEST (THRESHOLD_EVENTS_PER_PERIOD * EVENTS_PER_LOGGED_EVENT)
+
+#define PERIODS_TO_TEST 3
+#define TOTAL_SECONDS_FOR_TEST (PERIODS_TO_TEST * THRESHOLD_PERIOD)
+#define TOTAL_EVENTS (PERIODS_TO_TEST * EVENTS_PER_PERIOD_IN_TEST)
+
+int main(int argc, char **argv)
+{
+	struct bucket_conf c;
+	struct leaky_bucket b;
+	time_t start_time;
+	time_t event_time;
+	int ret;
+	int i;
+
+#ifdef TEST_LEAKY_BUCKET_DEBUG
+	printf("Testing with a rate of " RATE_STRING "\n");
+#endif
+	ret = bucket_conf_init(&c, RATE_STRING);
+	if (ret)
+		return ret;
+
+	bucket_init(&b);
+	start_time = b.tstamp;
+
+	for (i = 1; i <= TOTAL_EVENTS; i++) {
+		event_time = start_time + i * SECONDS_PER_EVENT;
+		ret = __bucket_account(&c, &b, 1, event_time);
+
+#ifdef TEST_LEAKY_BUCKET_DEBUG
+		if (ret)
+			printf("Logging entry %d at %ld %ld\n", i, event_time - start_time, b.tstamp);
+#else
+		if (i < THRESHOLD_EVENTS_PER_PERIOD) {
+			if (!ret){
+				fprintf(stderr, "Did not log initial events - FAIL.\n");
+				return -1;
+			}
+		} else {
+			if (!(i % EVENTS_PER_LOGGED_EVENT) && !ret) {
+				fprintf(stderr, "Did not log initial events - FAIL.\n");
+				return -1;
+			}
+		}
+#endif
+	}
+
+	return 0;
+}
+#endif
diff -urNp mcelog-1.0pre3_20120814_2.orig/mcelog.c mcelog-1.0pre3_20120814_2/mcelog.c
--- mcelog-1.0pre3_20120814_2.orig/mcelog.c	2014-03-26 10:19:47.403123651 -0400
+++ mcelog-1.0pre3_20120814_2/mcelog.c	2014-03-26 10:27:52.552138702 -0400
@@ -857,7 +857,7 @@ static void remove_pidfile(void)
 static void signal_exit(int sig)
 {
 	remove_pidfile();
-	_exit(sig);
+	_exit(EXIT_SUCCESS);
 }
 
 static void setup_pidfile(char *s)
@@ -1175,8 +1175,8 @@ static void drop_cred(void)
 static void process(int fd, unsigned recordlen, unsigned loglen, char *buf)
 {	
 	int i; 
-	int len;
-	int finish = 0;
+	int len, count;
+	int finish = 0, flags;
 
 	if (recordlen == 0) {
 		Wprintf("no data in mce record\n");
@@ -1189,7 +1189,14 @@ static void process(int fd, unsigned rec
 		return;
 	}
 
-	for (i = 0; (i < len / (int)recordlen) && !finish; i++) { 
+	count = len / (int)recordlen;
+	if (count == (int)loglen) {
+		if ((ioctl(fd, MCE_GETCLEAR_FLAGS, &flags) == 0) &&
+		    (flags & MCE_OVERFLOW))
+			Eprintf("Warning: MCE buffer is overflowed.\n");
+	}
+
+	for (i = 0; (i < count) && !finish; i++) {
 		struct mce *mce = (struct mce *)(buf + i*recordlen);
 		mce_prepare(mce);
 		if (numerrors > 0 && --numerrors == 0)
diff -urNp mcelog-1.0pre3_20120814_2.orig/mcelog.c.orig mcelog-1.0pre3_20120814_2/mcelog.c.orig
--- mcelog-1.0pre3_20120814_2.orig/mcelog.c.orig	2014-03-26 10:19:47.404123691 -0400
+++ mcelog-1.0pre3_20120814_2/mcelog.c.orig	2014-03-26 10:27:50.614139675 -0400
@@ -857,7 +857,7 @@ static void remove_pidfile(void)
 static void signal_exit(int sig)
 {
 	remove_pidfile();
-	_exit(sig);
+	_exit(EXIT_SUCCESS);
 }
 
 static void setup_pidfile(char *s)
@@ -1072,11 +1072,8 @@ static int modifier(int opt)
 		break;
 	case O_DAEMON:
 		daemon_mode = 1;
-		if (!logfile && !foreground)
-			logfile = logfile_default;
 		if (!(syslog_opt & SYSLOG_FORCE))
 			syslog_opt = SYSLOG_REMARK|SYSLOG_ERROR;
-
 		break;
 	case O_FILE:
 		inputfile = optarg;
@@ -1085,8 +1082,6 @@ static int modifier(int opt)
 		foreground = 1;	
 		if (!(syslog_opt & SYSLOG_FORCE))
 			syslog_opt = SYSLOG_FORCE;
-		if (logfile == logfile_default)
-			logfile = NULL;
 		break;
 	case O_NUMERRORS:
 		numerrors = atoi(optarg);
@@ -1113,6 +1108,9 @@ static int modifier(int opt)
 
 static void modifier_finish(void)
 {
+	if(!foreground && daemon_mode && !logfile && !(syslog_opt & SYSLOG_LOG)) {
+		logfile = logfile_default;
+	}
 	if (logfile) {
 		if (open_logfile(logfile) < 0) {
 			if (daemon_mode && !(syslog_opt & SYSLOG_FORCE))
diff -urNp mcelog-1.0pre3_20120814_2.orig/p4.c mcelog-1.0pre3_20120814_2/p4.c
--- mcelog-1.0pre3_20120814_2.orig/p4.c	2014-03-26 10:19:47.403123651 -0400
+++ mcelog-1.0pre3_20120814_2/p4.c	2014-03-26 10:27:54.254133110 -0400
@@ -147,6 +147,7 @@ static void decode_mca(__u32 mca, u64 tr
 		[3] = "External error",
 		[4] = "FRC error",
 		[5] = "Internal parity error",
+		[6] = "SMM Handler Code Access Violation",
 	};
 
 	if (mca & (1UL << 12)) {
@@ -360,6 +361,23 @@ void decode_intel_mc(struct mce *log, in
 		ivb_decode_model(cputype, log->bank, log->status, log->misc);
 		break;
 	}
+
+	/* IO MCA - reported as bus/interconnect with specific PP,T,RRRR,II,LL values
+	 * and MISCV set. MISC register points to root port that reported the error
+	 * need to cross check with AER logs for more details.
+	 * See: http://www.intel.com/content/www/us/en/architecture-and-technology/enhanced-mca-logging-xeon-paper.html
+	 */
+	if ((log->status & MCI_STATUS_MISCV) &&
+	    (log->status & 0xefff) == 0x0e0b) {
+		int	seg, bus, dev, fn;
+
+		seg = EXTRACT(log->misc, 32, 39);
+		bus = EXTRACT(log->misc, 24, 31);
+		dev = EXTRACT(log->misc, 19, 23);
+		fn = EXTRACT(log->misc, 16, 18);
+		Wprintf("IO MCA reported by root port %x:%02x:%02x.%x\n",
+			seg, bus, dev, fn);
+	}
 }
 
 char *intel_bank_name(int num)
diff -urNp mcelog-1.0pre3_20120814_2.orig/README.releases mcelog-1.0pre3_20120814_2/README.releases
--- mcelog-1.0pre3_20120814_2.orig/README.releases	1969-12-31 19:00:00.000000000 -0500
+++ mcelog-1.0pre3_20120814_2/README.releases	2014-03-26 10:27:49.190153638 -0400
@@ -0,0 +1,10 @@
+
+mcelog used to do released, but now switched to a rolling release
+scheme. That means the git tree is always kept stable and can
+be used directly in production.
+
+To simplify package management which likes to have 
+increasing version numbers the commits are regularly tagged
+with a number. The number starts (arbitarily) with 100.
+
+The tags are named vXXX (e.g. v100)
